pub type Token = struct {
    tag TokenTag,
    range TokenRange,
};

pub type TokenTag = enum {
    eof,
    invalid,
    identifier,
    special_identifier,
    string_literal,
    char_literal,
    int,
    float,
    open_paren,
    close_paren,
    open_brace,
    close_brace,
    open_bracket,
    close_bracket,
    comma,
    period,
    double_period,
    triple_period,
    colon,
    semicolon,
    fat_arrow,
    plus,
    minus,
    star,
    divide,
    modulo,
    bool_not,
    bit_not,
    bit_and,
    bit_or,
    bit_xor,
    less_than,
    greater_than,
    less_or_eql,
    greater_or_eql,
    left_shift,
    right_shift,
    eql,
    not_eql,
    plus_assign,
    minus_assign,
    star_assign,
    divide_assign,
    modulo_assign,
    bit_and_assign,
    bit_or_assign,
    bit_xor_assign,
    left_shift_assign,
    right_shift_assign,
    assign,
};

pub type TokenRange = struct {
    start u32,
    end u32,
};

pub type Lexer = struct {
    index u32,
    buffer [*]const u8,
};

type State = enum {
    start,
    identifier,
    at_sign,
    string_literal,
    string_literal_back_slash,
    char_literal,
    char_literal_back_slash,
    number,
    number_saw_period,
    plus,
    minus,
    star,
    divide,
    modulo,
    bit_and,
    bit_or,
    bit_xor,
    less_than,
    greater_than,
    left_shift,
    right_shift,
    comment,
    assign,
    bool_not,
    period,
    double_period,
};

pub fn next(self *Lexer) Token {
    var result Token;

    result.tag = TokenTag.eof;
    result.range.start = self.index;
    result.range.end = self.index;

    var state State = State.start;

    while true {
        var ch = self.buffer[self.index];

        switch (state) {
            State.start => switch (ch) {
                0 => {
                    result.tag = TokenTag.eof;
                    result.range.start = self.index;
                    result.range.end = self.index;

                    break;
                },

                ' ', '\r', '\n', '\t' => {},

                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                '_' => {
                    result.tag = TokenTag.identifier;
                    result.range.start = self.index;

                    state = State.identifier;
                },

                '@' => {
                    result.range.start = self.index;

                    state = State.at_sign;
                },

                '"' => {
                    result.tag = TokenTag.string_literal;
                    self.index += 1;
                    result.range.start = self.index;

                    state = State.string_literal;
                },

                '\'' => {
                    result.tag = TokenTag.char_literal;
                    self.index += 1;
                    result.range.start = self.index;

                    state = State.char_literal;
                },

                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
                    result.tag = TokenTag.int;
                    result.range.start = self.index;

                    state = State.number;
                },

                '(' => {
                    result.tag = TokenTag.open_paren;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                ')' => {
                    result.tag = TokenTag.close_paren;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '{' => {
                    result.tag = TokenTag.open_brace;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '}' => {
                    result.tag = TokenTag.close_brace;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '[' => {
                    result.tag = TokenTag.open_bracket;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                ']' => {
                    result.tag = TokenTag.close_bracket;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index; 

                    break;
                },

                ';' => {
                    result.tag = TokenTag.semicolon;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '=' => {
                    result.tag = TokenTag.assign;
                    result.range.start = self.index;

                    state = State.assign;
                },

                '!' => {
                    result.tag = TokenTag.bool_not;
                    result.range.start = self.index;

                    state = State.bool_not;
                },

                '~' => {
                    result.tag = TokenTag.bit_not;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '.' => {
                    result.tag = TokenTag.period;
                    result.range.start = self.index;

                    state = State.period;
                },

                '+' => {
                    result.tag = TokenTag.plus;
                    result.range.start = self.index;

                    state = State.plus;
                },

                '-' => {
                    result.tag = TokenTag.minus;
                    result.range.start = self.index;

                    state = State.minus;
                },

                '*' => {
                    result.tag = TokenTag.star;
                    result.range.start = self.index;

                    state = State.star;
                },

                '/' => {
                    result.tag = TokenTag.divide;
                    result.range.start = self.index;

                    state = State.divide;
                },

                '%' => {
                    result.tag = TokenTag.modulo;
                    result.range.start = self.index;

                    state = State.modulo;
                },

                ',' => {
                    result.tag = TokenTag.comma;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '&' => {
                    result.tag = TokenTag.bit_and;
                    result.range.start = self.index;

                    state = State.bit_and;
                },

                '|' => {
                    result.tag = TokenTag.bit_or;
                    result.range.start = self.index;

                    state = State.bit_or;
                },

                '^' => {
                    result.tag = TokenTag.bit_xor;
                    result.range.start = self.index;

                    state = State.bit_xor;
                },

                ':' => {
                    result.tag = TokenTag.colon;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '<' => {
                    result.tag = TokenTag.less_than;
                    result.range.start = self.index;

                    state = State.less_than;
                },

                '>' => {
                    result.tag = TokenTag.greater_than;
                    result.range.start = self.index;

                    state = State.greater_than;
                },

                else => {
                    result.tag = TokenTag.invalid;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },
            },

            State.identifier => switch (ch) {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                '_' => {},

                else => {
                    result.range.end = self.index;

                    break;
                },
            }, 

            State.at_sign => switch (ch) {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                '_' => {
                    result.range.start = self.index;
                    result.tag = TokenTag.special_identifier;
                    state = State.identifier;
                },

                else => {
                    result.tag = TokenTag.invalid;
                    result.range.end = self.index;

                    break;
                },
            },

            State.string_literal => switch (ch) {
                0, '\n' => {
                    result.tag = TokenTag.invalid;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '"' => {
                    result.range.end = self.index;
                    self.index += 1;

                    break;
                },

                '\\' => {
                    state = State.string_literal_back_slash;
                },

                else => {},
            },

            State.string_literal_back_slash => switch (ch) {
                0, '\n' => {
                    result.tag = TokenTag.invalid;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                else => {
                    state = State.string_literal;
                },
            },

            State.char_literal => switch (ch) {
                0, '\n' => {
                    result.tag = TokenTag.invalid;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '\\' => {
                    state = State.char_literal_back_slash;
                },

                '\'' => {
                    result.range.end = self.index;
                    self.index += 1;

                    break;
                },

                else => {},
            },


            State.char_literal_back_slash => switch (ch) {
                0, '\n' => {
                    result.tag = TokenTag.invalid;
                    result.range.start = self.index;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                else => {
                    state = State.char_literal;
                },
            },

            State.number => switch (ch) {
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {},

                '.' => {
                    result.tag = TokenTag.float;
                    state = State.number_saw_period;
                }, 

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.number_saw_period => switch (ch) {
                '.' => {
                    result.tag = TokenTag.int;
                    self.index -= 1;
                    result.range.end = self.index;

                    break;
                },

                else => {
                    state = State.number;

                    continue;
                },
            },

            State.plus => switch (ch) {
                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.plus_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.minus => switch (ch) {
                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.minus_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.star => switch (ch) {
                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.star_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },


            State.divide => switch (ch) {
                '/' => {
                    state = State.comment;
                },

                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.divide_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.modulo => switch (ch) {
                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.modulo_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.less_than => switch (ch) {
                '<' => {
                    result.tag = TokenTag.left_shift;
                    state = State.left_shift;
                },

                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.less_or_eql;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.greater_than => switch (ch) {
                '>' => {
                    result.tag = TokenTag.right_shift;
                    state = State.right_shift;
                },

                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.greater_or_eql;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.left_shift => switch (ch) {
                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.left_shift_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },
            
            State.right_shift => switch (ch) {
                '=' => {
                    self.index += 1;
                    result.range.end = self.index;
                    result.tag = TokenTag.right_shift_assign;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.comment => switch (ch) {
                0 => {
                    result.tag = TokenTag.eof;
                    result.range.start = self.index;
                    result.range.end = self.index;

                    break;
                },

                '\n' => {
                    state = State.start;
                },

                else => {},
            },

            State.assign => switch (ch) {
                '=' => {
                    result.tag = TokenTag.eql;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                '>' => {
                    result.tag = TokenTag.fat_arrow;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.bool_not => switch (ch) {
                '=' => {
                    result.tag = TokenTag.not_eql;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.period => switch (ch) {
                '.' => {
                    result.tag = TokenTag.double_period;
                    state = State.double_period;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            State.double_period => switch (ch) {
                '.' => {
                    result.tag = TokenTag.triple_period;
                    self.index += 1;
                    result.range.end = self.index;

                    break;
                },

                else => {
                    result.range.end = self.index;

                    break;
                },
            },

            else => {},
        }

        self.index += 1;
    }

    return result;
}
