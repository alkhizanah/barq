type Token = struct {
    tag Token::Tag,
    range Token::Range,
};

type Token::Tag = enum {
    eof,
    invalid,
    identifier,
    int,
    float,
    string_literal,
    char_literal,
    open_paren,
    close_paren,
    open_brace,
    close_brace,
    open_bracket,
    close_bracket,
    forward_slash,
    equal_sign,
    double_equal_sign,
    semicolon,
};

fn Token::Tag::to_string(self Token::Tag) [*]const u8 {
    if self == Token::Tag::eof {
        return "eof";
    } else if self == Token::Tag::identifier {
        return "identifier";
    } else if self == Token::Tag::int {
        return "int";
    } else if self == Token::Tag::float {
        return "float";
    } else if self == Token::Tag::string_literal {
        return "string_literal";
    } else if self == Token::Tag::char_literal {
        return "char_literal";
    } else if self == Token::Tag::open_paren {
        return "open_paren";
    } else if self == Token::Tag::close_paren {
        return "close_paren";
    } else if self == Token::Tag::open_brace {
        return "open_brace";
    } else if self == Token::Tag::close_brace {
        return "close_brace";
    } else if self == Token::Tag::open_bracket {
        return "open_bracket";
    } else if self == Token::Tag::close_bracket {
        return "close_bracket";
    } else if self == Token::Tag::forward_slash {
        return "forward_slash";
    } else if self == Token::Tag::equal_sign {
        return "equal_sign";
    } else if self == Token::Tag::double_equal_sign {
        return "double_equal_sign";
    } else if self == Token::Tag::semicolon {
        return "semicolon";
    }

    return "invalid";
}

type Token::Range = struct {
    start usize,
    end usize,
};

type Lexer = struct {
    index usize,
    buffer [*]const u8,
};

type Lexer::State = enum {
    start,
    identifier,
    number,
    string_literal,
    string_literal_back_slash,
    char_literal,
    char_literal_back_slash,
    forward_slash,
    comment,
    equal_sign,
};

fn Lexer::is_whitespace(ch u8) bool {
    return (ch == ' ') | (ch == '\r') | (ch == '\n') | (ch == '\t');
}

fn Lexer::is_identifier(ch u8) bool {
    return (!(ch < 'a') & !(ch > 'z')) | (!(ch < 'A') & !(ch > 'Z')) | (ch == '_');
}

fn Lexer::is_number(ch u8) bool {
    return !(ch < '0') & !(ch > '9');
}

fn Lexer::is_identifier_continue(ch u8) bool {
    return Lexer::is_identifier(ch) | Lexer::is_number(ch) | (ch == ':');
}

fn Lexer::next(self *Lexer) Token {
    var result Token;

    result.tag = Token::Tag::eof;
    result.range.start = self.index;
    result.range.end = self.index;

    var state Lexer::State = Lexer::State::start;

    while true {
        var ch = self.buffer[self.index];

        if state == Lexer::State::start {            
            if Lexer::is_whitespace(ch) {
            } else if Lexer::is_identifier(ch) {
                result.tag = Token::Tag::identifier;
                result.range.start = self.index;
                
                state = Lexer::State::identifier;
            } else if Lexer::is_number(ch) {
                result.tag = Token::Tag::int;
                result.range.start = self.index;
                
                state = Lexer::State::number;
            } else if ch == 0 {
                result.tag = Token::Tag::eof;
                result.range.start = self.index;
                result.range.end = self.index;

                break;
            } else if ch == '(' {
                result.tag = Token::Tag::open_paren;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == ')' {
                result.tag = Token::Tag::close_paren;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == '{' {
                result.tag = Token::Tag::open_brace;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == '}' {
                result.tag = Token::Tag::close_brace;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == '[' {
                result.tag = Token::Tag::open_bracket;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == ']' {
                result.tag = Token::Tag::close_bracket;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == ';' {
                result.tag = Token::Tag::semicolon;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == '"' {
                result.tag = Token::Tag::string_literal;
                result.range.start = self.index;
                
                state = Lexer::State::string_literal;
            } else if ch == '\'' {
                result.tag = Token::Tag::char_literal;
                result.range.start = self.index;
                
                state = Lexer::State::char_literal;
            } else if ch == '/' {
                result.tag = Token::Tag::forward_slash;
                result.range.start = self.index;
                
                state = Lexer::State::forward_slash;
            } else if ch == '=' {
                result.tag = Token::Tag::equal_sign;
                result.range.start = self.index;
                
                state = Lexer::State::equal_sign;
            } else {
                result.tag = Token::Tag::invalid;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            }
        } else if state == Lexer::State::identifier {
            if !Lexer::is_identifier_continue(ch) {
                result.range.end = self.index;

                break;
            }
        } else if state == Lexer::State::number {
            if ch == '.' {
                result.tag = Token::Tag::float;
            } else if !Lexer::is_number(ch) {
                result.range.end = self.index;

                break;
            }
        } else if state == Lexer::State::string_literal {
            if (ch == 0) | (ch == '\n') {
                result.tag = Token::Tag::invalid;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == '\\' {
                state = Lexer::State::string_literal_back_slash;
            } else if ch == '"' {
                result.range.end = self.index;
                self.index = self.index + 1;

                break;
            }
        } else if state == Lexer::State::string_literal_back_slash {
            if (ch == 0) | (ch == '\n') {
                result.tag = Token::Tag::invalid;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else {
                state = Lexer::State::string_literal;
            }
        } else if state == Lexer::State::char_literal {
            if (ch == 0) | (ch == '\n') {
                result.tag = Token::Tag::invalid;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else if ch == '\\' {
                state = Lexer::State::char_literal_back_slash;
            } else if ch == '\'' {
                result.range.end = self.index;
                self.index = self.index + 1;

                break;
            }
        } else if state == Lexer::State::char_literal_back_slash {
            if (ch == 0) | (ch == '\n') {
                result.tag = Token::Tag::invalid;
                result.range.start = self.index;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else {
                state = Lexer::State::char_literal;
            }
        } else if state == Lexer::State::forward_slash {
            if ch == '/' {
                state = Lexer::State::comment;
            } else {
                result.range.end = self.index;

                break;
            }
        } else if state == Lexer::State::comment {
            if ch == 0 {
                result.tag = Token::Tag::eof;
                result.range.start = self.index;
                result.range.end = self.index;

                break;
            }

            if ch == '\n' {
                state = Lexer::State::start;
            }
        } else if state == Lexer::State::equal_sign {
            if ch == '=' {
                result.tag = Token::Tag::double_equal_sign;
                self.index = self.index + 1;
                result.range.end = self.index;

                break;
            } else {
                result.range.end = self.index;

                break;
            }
        }

        self.index = self.index + 1;
    }

    return result;
}

// TODO: We still don't have a module system to refactor this stuff into main.cerm

type SYS = enum usize {
    write = 1,
};

fn syscall3(code SYS, arg1 usize, arg2 usize, arg3 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
          "{rsi}" (arg2),
          "{rdx}" (arg3),
        : "rcx", "r11", "memory"
    };
}

// TODO: We don't support slices yet
fn strlen(str [*]const u8) usize {
    var len usize = 0;

    while str[len] != 0 {
        len = len + 1;
    }

    return len;
}

const STDOUT = 1;

fn printc(c u8) {
    var cbuf [1]u8;
    cbuf[0] = c;

    syscall3(SYS::write, STDOUT, &cbuf as usize, cbuf.len);
}

fn prints(str [*]const u8) {
    syscall3(SYS::write, STDOUT, str as usize, strlen(str));
}


fn printu(n usize) {
    if n > 9 {
        var a = n / 10;
        n = n - a * 10;
        printu(a);
    }

    printc((n + '0') as u8);
}

fn main() {
    var lexer Lexer;

    lexer.index = 0;
    lexer.buffer = "([{(}])";

    prints("buffer: ");
    prints(lexer.buffer);
    printc('\n');

    while true {
        var token = Lexer::next(&lexer);

        prints("token tag: ");
        prints(Token::Tag::to_string(token.tag));
        prints(", ");
        prints("token range: ");
        printu(token.range.start);
        prints("..");
        printu(token.range.end);
        printc('\n');

        if token.tag == Token::Tag::eof {
            break;
        }
    }
}
